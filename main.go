package main

import (
	"fmt"
	"sync"
	"time"
)

func write(n int) {
	for i := 0; i < 10; i++ {
		fmt.Printf("number %d = %d\n", n, i)
		// блокирующая операция
		// time.Sleep(1)
	}
}

var value = 23
var mut = sync.Mutex{}

func doRequest(results chan string) {
	results <- "some data"
}

func storeData(results chan string) {
	data := <-results
	fmt.Printf("data to store = %s\n", data)
}

func main() {
	// Concurrency - Конкурентность - Этот подход означает,
	// что задачи выполняются последовательно, одна за другой,
	// но переключаются (context switch) между собой с определенной частотой.
	// Каждая задача может иметь свой собственный поток выполнения,
	// но они делят ресурсы (например, процессорное время) и конкурируют за них.
	// Похоже на ситуацию, когда несколько человек стоят в очереди
	// и поочередно выполняют свои задачи.
	//
	//  ========
	// ||       || - - Thr1 - - - - - - - - Thr1 - - - - - - - - - Thr1 - -
	// || CORE  ||
	// ||       || - - - - - - - Thr2 - - - - - - - - - Thr2 - - - - -  - -
	//  ========
	//

	// Parallelism - Параллельность - В этом подходе задачи выполняются
	// одновременно, в отдельных потоках или процессах,
	// и могут использовать разные ресурсы.
	// Это позволяет увеличить производительность,
	// так как задачи могут работать параллельно,
	// не мешая друг другу.
	// Похоже на ситуацию, когда несколько людей одновременно
	// выполняют свои задачи, используя разные инструменты и ресурсы.
	//
	//  -------
	// |       |
	// | CORE1 | - - Thr1 - - - - - - - - Thr1 - - - - - - - - - Thr1 - -
	// |       |
	//  -------
	//
	//  -------
	// |       |
	// | CORE2 | - - Thr2 - - - - - - - - Thr2 - - - - - - - - - Thr2 - -
	// |       |
	//  -------
	//

	// Нет никакого порядка исполнения потоков.
	// Может сначала исполниться метод с параметром 2, а потом 1 и т.д.
	// Планировщик GO сам определяет, какую go-рутину когда запускать,
	// НО может вмешаться в его работу с помощью блокирующих операций (sleep).
	/*
		go write(1)
		go write(2)
		go write(3)
	*/

	// Состояние гонки.
	// Одна горутина пытается изменить значение, а другая - прочитать.
	// Другие горутины будут ждать, пока мьютекс заблокирован.
	// Но такой способ не принято использовать в GO.
	// go run -race main.go
	/*
		printValue := func() {
			mut.Lock()
			value++
			fmt.Println(value)
			mut.Unlock()
		}

		go printValue()
		go printValue()
		go printValue()
	*/

	// Каналы. Горутины могут обмениваться данными, благодаря каналам.
	results := make(chan string)
	go doRequest(results)
	go storeData(results)

	// Блокировать выход из терминала
	time.Sleep(10 * time.Second)
	fmt.Println("end sleep...")
}
